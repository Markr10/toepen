using Newtonsoft.Json;
using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Net;
using System.Net.Sockets;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using toepenTest.Json;

namespace toepenTest.Connection
{
    // The delegate type for hooking up change notifications.
    public delegate void FourClientsEventHandler();
    public delegate void CheckCardEventHandler(String card, int clientId);
    public delegate void CheckDirtyLaundryEventHandler(bool checkDirtyLaundry, int clientId);


    public class Server
    {
        // An event that can be used to be notified whenever
        // there are change notifications
        public event FourClientsEventHandler FourClientsEvent;
        public event CheckCardEventHandler CheckCardEvent;
        public event CheckDirtyLaundryEventHandler CheckDirtyLaundryEvent;

        //private static IPAddress IP = Conn.GetIP();
        private static IPAddress IP = IPAddress.Parse(Conn.GetLocalIP());
        private TcpListener _server;
        private Dictionary<TcpClient, int> clientList;

        private bool isSearching;
        private bool holdConnection;
        private Game gameToepen;


        public Server(int port)
        {
            /* To stop all the threads on exit, use Environment.Exit(0); */
            Console.WriteLine("Multi-Threaded TCP Server");
            Console.WriteLine("IPAddress: " + IP.ToString());
            Console.WriteLine("Port: " + port);

            clientList = new Dictionary<TcpClient, int>();
            _server = new TcpListener(IP, port);
            _server.Start();

            isSearching = true;
            holdConnection = true;
            gameToepen = null;

            Thread searchThread = new Thread(SearchClients);
            searchThread.Start();
        }

        // Invoke the changed event; called whenever there are change notifications
        protected virtual void OnFourClients()
        {
            if (FourClientsEvent != null)
            {
                FourClientsEvent();
            }
        }

        protected virtual void OnCheckCard(String card, int clientId)
        {
            if (CheckCardEvent != null)
            {
                CheckCardEvent(card, clientId);
            }
        }

        protected virtual void OnCheckDirtyLaundry(bool checkDirtyLaundry, int clientId)
        {
            if (CheckDirtyLaundryEvent != null)
            {
                CheckDirtyLaundryEvent(checkDirtyLaundry, clientId);
            }
        }

        public async void SearchClients()
        {
            while (isSearching)
            {
                // wait for client connection, then go further
                TcpClient newClient = await _server.AcceptTcpClientAsync();

                // client found
                // create a thread to handle communication
                Thread recieveThread = new Thread(new ThreadStart(delegate { GetResponse(newClient); }));
                recieveThread.Start();
                clientList.Add(newClient, clientList.Count);

                Console.WriteLine("client: " + clientList[newClient]);

                PlayerAdded playerAdded = new PlayerAdded();
                playerAdded.IndexOfNewPlayer = clientList[newClient];
                SendSerializeMessageAll(JsonConvert.SerializeObject(playerAdded));
                SendEarlierPlayers(newClient, playerAdded);

                if (clientList.Count == 4)
                {
                    isSearching = false;
                    OnFourClients();
                }
            }
        }

        public void GetResponse(TcpClient client)
        {
            //string ipClient = client.Client.LocalEndPoint.ToString();
            //string[] output = ipClient.Split(new[] { ':', ' ' });

            // sets reader stream
            StreamReader sReader = new StreamReader(client.GetStream(), Encoding.ASCII);
            // you could use the NetworkStream to read and write, 
            // but there is no forcing flush, even when requested


            try
            {
                while (holdConnection)
                {
                    // reads from stream
                    string sDataIncomming = sReader.ReadLine();
                    Console.WriteLine("Server recieved from client " + clientList[client] + " : " + sDataIncomming);
                    HandleResponse(sDataIncomming, clientList[client]);
                }
            }
            catch (Exception e)
            {
                Console.WriteLine("Connection with client " + clientList[client] + " is lost!; " + e);
                // terminate thread when connection is lost
            }
        }

        private void HandleResponse(string sDataIncomming, int clientId)
        {
            switch (JsonConvert.DeserializeObject<Message>(sDataIncomming).Type)
            {
                case "PlayedCard":
                    OnCheckCard(JsonConvert.DeserializeObject<PlayedCard>(sDataIncomming).Card, clientId);
                    break;
                case "DirtyLaundry":
                    OnCheckDirtyLaundry(JsonConvert.DeserializeObject<DirtyLaundry>(sDataIncomming).CheckDirtyLaundry, clientId);
                    break;
            }
        }

        /// <summary>
        /// Send message to a client
        /// </summary>
        /// <param name="messageObj">Must be a serialize Message object</param>
        /// <param name="client">The reciever of the message</param>
        private void Send(object messageObj, TcpClient client)
        {
            try
            {
                // sets writer stream
                StreamWriter sWriter = new StreamWriter(client.GetStream(), Encoding.ASCII);


                // write data and make sure to flush, or the buffer will continue to 
                // grow, and your data might not be sent when you want it, and will
                // only be sent once the buffer is filled
                sWriter.WriteLine(messageObj);
                sWriter.Flush();
                Console.WriteLine("Server sent to client " + clientList[client] + " : " + messageObj);


                //// to write something back.
                //string response = Console.ReadLine();
                //sWriter.WriteLine(response);
            }
            catch (Exception e)
            {
                Console.WriteLine("Server can not send message " + messageObj + " to client " + clientList[client] + "!; " + e);
            }
        }

        /// <summary>
        /// Send a message to a client in a separate thread
        /// </summary>
        /// <param name="messageObj">Must be a serialize Message object</param>
        /// <param name="client">The reciever of the message</param>
        public void SendMessage(object messageObj, TcpClient client)
        {
            Thread sendThread = new Thread(new ThreadStart(delegate { Send(messageObj, client); }));
            sendThread.Start();
        }

        /// <summary>
        /// Send a message to a specific client
        /// </summary>
        /// <param name="messageObj">Must be a serialize Message object</param>
        /// <param name="clientId">The clientId van the TcpClient</param>
        /// <remarks>Message will be send in a seperate thread</remarks>
        public void SendSerializeMessageWithClientId(object messageObj, int clientId)
        {
            SendMessage(messageObj, clientList.Keys.ToArray()[clientId]);
        }

        /// <summary>
        /// Send a message to all the clients
        /// </summary>
        /// <param name="messageObj">Must be a serialize Message object</param>
        /// <remarks>Message will be send in a seperate thread</remarks>
        public void SendSerializeMessageAll(object messageObj)
        {
            foreach (TcpClient client in clientList.Keys)
            {
                SendMessage(messageObj, client);
            }
        }

        /// <summary>
        /// Send a message to all the clients
        /// </summary>
        /// <param name="messageObj">A Message object</param>
        /// <remarks>Message will be send in a seperate thread</remarks>
        public void SendMessageAll(Message messageObj)
        {
            foreach (TcpClient client in clientList.Keys)
            {
                SendMessage(JsonConvert.SerializeObject(messageObj), client);
            }
        }

        /// <summary>
        /// Send a message to all the clients except one
        /// </summary>
        /// <param name="messageObj">A Message object</param>
        /// <param name="clientId">The client id where no message has to be sent</param>
        /// <remarks>Message will be send in a seperate thread</remarks>
        public void SendMessageAllExceptOne(Message messageObj, int clientId)
        {
            TcpClient[] clientArray = clientList.Keys.ToArray();

            for (int i = 0; i < clientArray.Length; i++)
            {
                if (i != clientId)
                {
                    SendMessage(JsonConvert.SerializeObject(messageObj), clientArray[i]);
                }
            }
        }

        /// <summary>
        /// Send earlier players to a client
        /// </summary>
        /// <param name="client">The client to which the players must be send</param>
        /// <param name="playerAdded">The PlayerAdded object which was earlier used to send the new player</param>
        public void SendEarlierPlayers(TcpClient client, PlayerAdded playerAdded)
        {
            foreach (TcpClient clientFromList in clientList.Keys)
            {
                Console.WriteLine("clientFromList " + clientList[clientFromList] + ";clientList " + clientList[client]);
                Console.WriteLine("clientListKeys " + clientList.Keys.Count);
                if (clientList[clientFromList] == clientList[client])
                {
                    return;
                }

                playerAdded.IndexOfNewPlayer = clientList[clientFromList];
                Console.WriteLine("Send clientFromListId " + playerAdded.IndexOfNewPlayer + " to " + clientList[client]);

                SendMessage(JsonConvert.SerializeObject(playerAdded), client);
            }
        }

        /// <summary>
        /// Send StartGame to all the clients
        /// </summary>
        /// <param name="startGameObj">A StartGame object</param>
        /// <param name="playerNames">The array with the names of the players</param>
        public void SendStartGameAll(StartGame startGameObj, string[] playerNames)
        {
            TcpClient[] clientArray = clientList.Keys.ToArray();

            // Stop if both lists are not equal.
            if (clientArray.Length != playerNames.Length)
            {
                return;
            }

            for (int i = 0; i < clientArray.Length; i++)
            {
                startGameObj.PlayerName = playerNames[i];
                SendMessage(JsonConvert.SerializeObject(startGameObj), clientArray[i]);
            }
        }

        /// <summary>
        /// Send the dealt cards to the players
        /// </summary>
        public void SendCards(Dictionary<String, Player>.ValueCollection players)
        {
            foreach (Player player in players)
            {
                PlayerCards playerCardsObj = new PlayerCards();
                playerCardsObj.Card1 = player.GetCards()[0].ToString();
                playerCardsObj.Card2 = player.GetCards()[1].ToString();
                playerCardsObj.Card3 = player.GetCards()[2].ToString();
                playerCardsObj.Card4 = player.GetCards()[3].ToString();

                SendSerializeMessageWithClientId(JsonConvert.SerializeObject(playerCardsObj), player.GetClientId());
            }
        }

        /// <summary>
        /// Send extra cards in case of dirty laundry to a player
        /// </summary>
        /// <param name="hasNewCards">If is was possible to give the player new cards</param>
        /// <param name="player">The player for who the message is</param>
        public void SendExtraCards(bool hasNewCards, Player player)
        {
            PlayerExtraCards playerCardsObj = new PlayerExtraCards();
            playerCardsObj.PlayerGetExtraCards = hasNewCards;

            if (hasNewCards)
            {
                playerCardsObj.Card1 = player.GetCards()[0].ToString();
                playerCardsObj.Card2 = player.GetCards()[1].ToString();
                playerCardsObj.Card3 = player.GetCards()[2].ToString();
                playerCardsObj.Card4 = player.GetCards()[3].ToString();
            }
            else
            {
                playerCardsObj.Card1 = playerCardsObj.Card2 = playerCardsObj.Card3 = playerCardsObj.Card4 = null;
            }

            SendSerializeMessageWithClientId(JsonConvert.SerializeObject(playerCardsObj), player.GetClientId());
        }

        public void SendNoCardsAvailable()
        {
            MessageToList messageToListObj = new MessageToList();
            messageToListObj.Text = "Er zijn geen kaarten meer beschikbaar.";
            SendSerializeMessageAll(JsonConvert.SerializeObject(messageToListObj));
        }

        /// <summary>
        /// Determines player turn
        /// </summary>
        public void SendPlayerTurn(Player player)
        {
            PlayerTurn playerTurnObj = new PlayerTurn();

            MessageToList messageToListObj = new MessageToList();
            messageToListObj.Text = player.GetNameWithFirstUppercase() + " is aan de beurt.";

            SendSerializeMessageWithClientId(JsonConvert.SerializeObject(playerTurnObj), player.GetClientId());
            SendMessageAllExceptOne(messageToListObj, player.GetClientId());
        }

        /// <summary>
        /// Send boolean dirtyLaundry
        /// </summary>
        public void SendMessageDirtyLaundry(bool dirtyLaundry, Player player)
        {
            MessageToList messageToListObj = new MessageToList();
            if (dirtyLaundry == true)
            {
                messageToListObj.Text = player.GetNameWithFirstUppercase() + " meldt vuile was.";
            }
            else
            {
                messageToListObj.Text = player.GetNameWithFirstUppercase() + " meldt geen vuile was.";
            }
            
            SendMessageAll(messageToListObj);
        }

        /// <summary>
        /// Send message to all players and winner about the round
        /// </summary>
        /// <param name="forTrick">The current round or end of 4 rounds</param>
        /// <param name="player">The current players in game</param>
        public void SendMessageWinner(bool forTrick, Player player)
        {
            MessageToList messageToListObj = new MessageToList();
            if (forTrick == true)
            {
                messageToListObj.Text = "Je hebt deze slag gewonnen.";
                SendSerializeMessageWithClientId(JsonConvert.SerializeObject(messageToListObj), player.GetClientId());

                messageToListObj.Text = player.GetNameWithFirstUppercase() + " heeft de slag gewonnen.";
                SendMessageAll(messageToListObj);
            }
            else
            {
                messageToListObj.Text = "Je hebt deze slag en ronde gewonnen.";
                SendSerializeMessageWithClientId(JsonConvert.SerializeObject(messageToListObj), player.GetClientId());

                messageToListObj.Text = player.GetNameWithFirstUppercase() + " heeft de slag en ronde gewonnen.";
                SendMessageAll(messageToListObj);
            }
        }

        /// <summary>
        /// Send a card from a player to other players
        /// </summary>
        /// <param name="card">The card from the player who played</param>
        /// <param name="clientId">The clientId from the player who played the card</param>
        public void SendCardToOtherPlayers(String card, int clientId)
        {
            PlayerPlayedCard playerPlayedCardObj = new PlayerPlayedCard();
            playerPlayedCardObj.Card = card;

            for (int i = 0; i < clientList.Count; i++)
            {
                if (clientId != i)
                {
                    playerPlayedCardObj.IndexOfCardField = (clientList.Count - i + clientId) % clientList.Count;
                    SendSerializeMessageWithClientId(JsonConvert.SerializeObject(playerPlayedCardObj), i);
                } 
            }
        }

        public void SendPlayedCardValid(int clientId, bool cardValid, int indexOfCard)
        {
            PlayedCardValid playedCardValidObj = new PlayedCardValid();
            playedCardValidObj.CardValid = cardValid;
            playedCardValidObj.IndexOfCardField = indexOfCard;

            SendSerializeMessageWithClientId(JsonConvert.SerializeObject(playedCardValidObj), clientId);
        }

        /// <summary>
        /// Send score to all the clients in separate threads
        /// </summary>
        /// <param name="players">players of the game</param>
        public void SendScoreToAll(Dictionary<String, Player>.ValueCollection players, int roundNumber)
        {
            ResetScoreToList resetScoreToListObj = new ResetScoreToList();
            resetScoreToListObj.Text = "---  Ronde: " + roundNumber + "  ---";
            SendMessageAll(resetScoreToListObj);

            foreach (Player player in players)
            {
                ScoreToList scoreToListObj = new ScoreToList();
                scoreToListObj.Text = player.GetNameWithFirstUppercase() + ": " + player.GetPenaltyPoints() + " pt";
                SendMessageAll(scoreToListObj);
            }
        }

        /// <summary>
        /// Send start new trick to clients, to prepare the clients for the next trick
        /// </summary>
        public void SendStartNewTrick()
        {
            StartNewTrick startNewTrickObj = new StartNewTrick();
            SendMessageAll(startNewTrickObj);
        }

        /// <summary>
        /// Send start new round to clients, to prepare the clients for the next round
        /// </summary>
        public void SendStartNewRound()
        {
            StartNewRound startNewRoundObj = new StartNewRound();
            SendMessageAll(startNewRoundObj);
        }

        public void StartGame()
        {
            // start Game
            gameToepen = new Game(clientList.Count);
            StartGame startGameObj = new StartGame();
            SendStartGameAll(startGameObj, gameToepen.GetPlayerNames());

            // Eerste keer als spel gestart wordt, anders hebben de spelers hun namen niet.
            gameToepen.NextRound();
        }
    }
}
