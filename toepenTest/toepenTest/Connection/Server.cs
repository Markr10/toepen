using Newtonsoft.Json;
using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Net;
using System.Net.Sockets;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using toepenTest.Json;

namespace toepenTest.Connection
{
    // The delegate type for hooking up change notifications.
    public delegate void FourClientsEventHandler();
    public delegate void CheckCardEventHandler(String card, int clientId);


    public class Server
    {
        // An event that can be used to be notified whenever
        // there are change notifications
        public event FourClientsEventHandler FourClientsEvent;
        public event CheckCardEventHandler CheckCardEvent;

        //private static IPAddress IP = Conn.GetIP();
        private static IPAddress IP = IPAddress.Parse(Conn.GetLocalIP());
        private TcpListener _server;
        private Dictionary<TcpClient, int> clientList;

        private bool isSearching;
        private bool holdConnection;
        private Game gameToepen;


        public Server(int port)
        {
            /* To stop all the threads on exit, use Environment.Exit(0); */
            Console.WriteLine("Multi-Threaded TCP Server");
            Console.WriteLine("IPAddress: " + IP.ToString());
            Console.WriteLine("Port: " + port);

            clientList = new Dictionary<TcpClient, int>();
            _server = new TcpListener(IP, port);
            _server.Start();

            isSearching = true;
            holdConnection = true;
            gameToepen = null;

            Thread searchThread = new Thread(SearchClients);
            searchThread.Start();
        }

        // Invoke the changed event; called whenever there are change notifications
        protected virtual void OnFourClients()
        {
            if (FourClientsEvent != null)
            {
                FourClientsEvent();
            }
        }

        protected virtual void OnCheckCard(String card, int clientId)
        {
            if (CheckCardEvent != null)
            {
                CheckCardEvent(card, clientId);
            }
        }

        public async void SearchClients()
        {
            while (isSearching)
            {
                // wait for client connection, then go further
                TcpClient newClient = await _server.AcceptTcpClientAsync();

                // client found
                // create a thread to handle communication
                Thread recieveThread = new Thread(new ThreadStart(delegate { GetResponse(newClient); }));
                recieveThread.Start();
                clientList.Add(newClient, clientList.Count);

                Console.WriteLine("client: " + clientList[newClient]);

                PlayerAdded playerAdded = new PlayerAdded();
                playerAdded.IndexOfNewPlayer = clientList[newClient];
                SendSpecificMessageAll(JsonConvert.SerializeObject(playerAdded));
                SendEarlierPlayers(newClient, playerAdded);

                if (clientList.Count == 4)
                {
                    isSearching = false;
                    OnFourClients();
                }
            }
        }

        public void GetResponse(TcpClient client)
        {
            //string ipClient = client.Client.LocalEndPoint.ToString();
            //string[] output = ipClient.Split(new[] { ':', ' ' });

            // sets reader stream
            StreamReader sReader = new StreamReader(client.GetStream(), Encoding.ASCII);
            // you could use the NetworkStream to read and write, 
            // but there is no forcing flush, even when requested


            try
            {
                while (holdConnection)
                {
                    // reads from stream
                    string sDataIncomming = sReader.ReadLine();
                    Console.WriteLine("Server recieved from client " + clientList[client] + " : " + sDataIncomming);
                    HandleResponse(sDataIncomming, clientList[client]);
                }
            }
            catch (Exception e)
            {
                Console.WriteLine("Connection with client " + clientList[client] + " is lost!; " + e);
                // terminate thread when connection is lost
            }
        }

        private void HandleResponse(string sDataIncomming, int clientId)
        {
            switch (JsonConvert.DeserializeObject<Message>(sDataIncomming).Type)
            {
                case "PlayedCard":
                    OnCheckCard(JsonConvert.DeserializeObject<PlayedCard>(sDataIncomming).Card, clientId);
                    //// shows content on the console.
                    //Console.WriteLine(playedCard.Name + " > " + playedCard.Card);
                    break;
            }
        }

        /// <summary>
        /// Send a message to a client in a separate thread
        /// </summary>
        /// <param name="messageObj">Must be a serialize Message object</param>
        /// <param name="client">The reciever of the message</param>
        public void SendMessage(object messageObj, TcpClient client)
        {
            Thread sendThread = new Thread(new ThreadStart(delegate { Send(messageObj, client); }));
            sendThread.Start();
        }

        /// <summary>
        /// Send message to a client
        /// </summary>
        /// <param name="messageObj">Must be a serialize Message object</param>
        /// <param name="client">The reciever of the message</param>
        private void Send(object messageObj, TcpClient client)
        {
            try
            {
                // sets writer stream
                StreamWriter sWriter = new StreamWriter(client.GetStream(), Encoding.ASCII);


                // write data and make sure to flush, or the buffer will continue to 
                // grow, and your data might not be sent when you want it, and will
                // only be sent once the buffer is filled
                sWriter.WriteLine(messageObj);
                sWriter.Flush();
                Console.WriteLine("Server sent to client " + clientList[client] + " : " + messageObj);


                //// to write something back.
                //string response = Console.ReadLine();
                //sWriter.WriteLine(response);
            }
            catch (Exception e)
            {
                Console.WriteLine("Server can not send message " + messageObj + " to client " + clientList[client] + "!; " + e);
            }
        }

        /// <summary>
        /// Send a message to a specific client
        /// </summary>
        /// <param name="messageObj">Must be a serialize Message object</param>
        /// <param name="clientId">The clientId van the TcpClient</param>
        public void SendMessageWithClientId(object messageObj, int clientId)
        {
            SendMessage(messageObj, clientList.Keys.ToArray()[clientId]);
        }

        /// <summary>
        /// Send a specific message to all the clients in separate threads
        /// </summary>
        /// <param name="messageObj">Must be a serialize Message object</param>
        public void SendSpecificMessageAll(object messageObj)
        {
            foreach (TcpClient client in clientList.Keys)
            {
                SendMessage(messageObj, client);
            }
        }

        /// <summary>
        /// Send a messages to all the clients in separate threads
        /// </summary>
        /// <param name="messageObj">A Message object</param>
        public void SendMessageAll(Message messageObj)
        {
            foreach (TcpClient client in clientList.Keys)
            {
                SendMessage(JsonConvert.SerializeObject(messageObj), client);
            }
        }

        /// <summary>
        /// Send a messages to all the clients except one, in separate threads
        /// </summary>
        /// <param name="messageObj">A Message object</param>
        /// <param name="clientId">The client id where no message has to be sent</param>
        public void SendMessageAllExceptOne(Message messageObj, int clientId)
        {
            TcpClient[] clientArray = clientList.Keys.ToArray();

            for (int i = 0; i < clientArray.Length; i++)
            {
                if (i != clientId)
                {
                    SendMessage(JsonConvert.SerializeObject(messageObj), clientArray[i]);
                }
            }
        }

        /// <summary>
        /// Send earlier players to a client
        /// </summary>
        /// <param name="client">The client to which the players must be send</param>
        /// <param name="playerAdded">The PlayerAdded object which was earlier used to send the new player</param>
        public void SendEarlierPlayers(TcpClient client, PlayerAdded playerAdded)
        {
            foreach (TcpClient clientFromList in clientList.Keys)
            {
                Console.WriteLine("CFromL " + clientList[clientFromList] + ";CL " + clientList[client]);
                Console.WriteLine("CLKeys " + clientList.Keys.Count);
                if (clientList[clientFromList] == clientList[client])
                {
                    return;
                }

                playerAdded.IndexOfNewPlayer = clientList[clientFromList];
                Console.WriteLine("Send CFromLNumber " + playerAdded.IndexOfNewPlayer + " to " + clientList[client]);
                Console.WriteLine("Info " + JsonConvert.SerializeObject(playerAdded));
                
                SendMessage(JsonConvert.SerializeObject(playerAdded), client);
            }
        }

        /// <summary>
        /// Send StartGame to all the clients in separate threads
        /// </summary>
        /// <param name="startGameObj">A StartGame object</param>
        /// <param name="playerNames">The array with the names of the players</param>
        public void SendStartGameAll(StartGame startGameObj, string[] playerNames)
        {
            TcpClient[] clientArray = clientList.Keys.ToArray();

            // Stop if both lists are not equal.
            if (clientArray.Length != playerNames.Length)
            {
                return;
            }

            for (int i = 0; i < clientArray.Length; i++)
            {
                startGameObj.PlayerName = playerNames[i];
                SendMessage(JsonConvert.SerializeObject(startGameObj), clientArray[i]);
            }
        }

        public void StartGame()
        {
            // start Game
            gameToepen = new Game(clientList.Count);
            StartGame startGameObj = new StartGame();
            SendStartGameAll(startGameObj, gameToepen.GetPlayerNames());

            
            // Eerste keer als spel gestart wordt, anders hebben de spelers hun namen niet.
            gameToepen.NextRound();
        }

        /// <summary>
        /// Deal the card and send them to the players
        /// </summary>
        public void SendCards(Dictionary<String, Player> players)
        {
            for (int i = 1; i <= players.Count; i++)
            {
                PlayerCards playerCardsObj = new PlayerCards();
                playerCardsObj.Card1 = players["Player" + i].GetCards()[0].ToString();
                playerCardsObj.Card2 = players["Player" + i].GetCards()[1].ToString();
                playerCardsObj.Card3 = players["Player" + i].GetCards()[2].ToString();
                playerCardsObj.Card4 = players["Player" + i].GetCards()[3].ToString();

                SendMessageWithClientId(JsonConvert.SerializeObject(playerCardsObj),
                    players["Player" + i].GetClientId());
            }
        }

        /// <summary>
        /// Determines player turn
        /// </summary>
        public void SendPlayerTurn(Player player)
        {
            PlayerTurn playerTurnObj = new PlayerTurn();

            MessageToList messageToListObj = new MessageToList();
            messageToListObj.Text = "Speler " + (player.GetClientId() + 1) + " is aan de beurt.";

            SendMessageWithClientId(JsonConvert.SerializeObject(playerTurnObj), player.GetClientId());
            SendMessageAllExceptOne(messageToListObj, player.GetClientId());
        }

        /// <summary>
        /// Send a card from a player to other players
        /// </summary>
        /// <param name="card">The card from the player who played</param>
        /// <param name="clientId">The clientId from the player who played the card</param>
        public void SendCardToOtherPlayers(String card, int clientId)
        {
            PlayerPlayedCard playerPlayedCardObj = new PlayerPlayedCard();
            playerPlayedCardObj.Card = card;

            for (int i = 0; i < clientList.Count; i++)
            {
                if (clientId != i)
                {
                    playerPlayedCardObj.IndexOfCardField = (clientList.Count - i + clientId) % clientList.Count;
                    SendMessageWithClientId(JsonConvert.SerializeObject(playerPlayedCardObj), i);
                } 
            }
        }

        public void SendPlayedCardValid(int clientId, bool cardValid, int indexOfCard)
        {
            PlayedCardValid playedCardValidObj = new PlayedCardValid();
            playedCardValidObj.CardValid = cardValid;
            playedCardValidObj.IndexOfCardField = indexOfCard;

            SendMessageWithClientId(JsonConvert.SerializeObject(playedCardValidObj), clientId);
        }
    }
}
