using Newtonsoft.Json;
using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Net;
using System.Net.Sockets;
using System.Text;
using System.Threading;
using System.Threading.Tasks;

namespace toepenTest.Connection
{
    // A delegate type for hooking up change notifications.
    public delegate void AddedEventHandler(object sender, int e);
    public delegate void FourClientsEventHandler();


    public class Server
    {
        private Dictionary<TcpClient, int> threadList;

        //private static IPAddress IP = Conn.GetIP();
        private static IPAddress IP = IPAddress.Parse(Conn.GetLocalIP());
        private TcpListener _server;
        private Boolean _isRunning;
        private ArrayList connectedClients;
        
        // An event that clients can use to be notified whenever the
        // elements of the clients added.
        public event AddedEventHandler Added;
        public event FourClientsEventHandler FourClients;

        // proef om alle threads melding te geven
        private EventWaitHandle _waitHandle = new EventWaitHandle(false, EventResetMode.ManualReset);
        

        public Server(int port)
        {
            Console.WriteLine("Multi-Threaded TCP Server");
            Console.WriteLine("IPAddress: " + IP.ToString());
            Console.WriteLine("Port: " + port);

            threadList = new Dictionary<TcpClient, int>();
            connectedClients = new ArrayList();
            _server = new TcpListener(IP, port);
            _server.Start();

            _isRunning = true;

            Thread loopThread = new Thread(LoopClients);
            loopThread.Start();

        }

        // Invoke the Changed event; called whenever list changes
        protected virtual void OnAdded(int e)
        {
            if (Added != null)
            {
                Added(this, e);
            }
        }

        protected virtual void OnFourClients()
        {
            if (FourClients != null)
            {
                FourClients();
            }
        }

        public void LoopClients()
        {
            while (_isRunning)
            {
                // wait for client connection, then go further
                TcpClient newClient = _server.AcceptTcpClient();

                // client found.
                // create a thread to handle communication
                Thread t = new Thread(new ParameterizedThreadStart(HandleClient));
                threadList.Add(newClient, threadList.Count);
                t.Start(newClient);
                
                
                //HandleClient(newClient);

                Console.WriteLine(t.ToString());
                Console.WriteLine("client: " + threadList[newClient]);
                OnAdded(threadList[newClient]);
                    //.makePlayerActive(threadList[newClient]);
                if (threadList.Count >= 2)
                {
                    Thread.Sleep(10000);
                    _waitHandle.Set();
                }

                if (threadList.Count == 4)
                {
                    _isRunning = false;
                    OnFourClients();
                }
            }
        }

        public void HandleClient(object obj)
        {
            // retrieve client from parameter passed to thread
            TcpClient client = (TcpClient)obj;

            String ipClient = client.Client.LocalEndPoint.ToString();

            var output = ipClient.Split(new[] { ':', ' ' });

            connectedClients.Add(output[0].ToString());

            // sets two streams
            StreamWriter sWriter = new StreamWriter(client.GetStream(), Encoding.ASCII);
            StreamReader sReader = new StreamReader(client.GetStream(), Encoding.ASCII);
            // you could use the NetworkStream to read and write, 
            // but there is no forcing flush, even when requested

            Boolean bClientConnected = true;

            String sData = null;

            while (bClientConnected)
            {
                try
                {
                    // reads from stream
                    sData = sReader.ReadLine();

                    PlayCard playCard = JsonConvert.DeserializeObject<PlayCard>(sData);

                    // shows content on the console.
                    Console.WriteLine(playCard.Name + " > " + playCard.Card);

                    //string response = Console.ReadLine();
                    //// to write something back.
                    //sWriter.WriteLine(response);
                    _waitHandle.WaitOne();
                    Console.WriteLine("Send to " + playCard.Name);
                    
                    sWriter.WriteLine("ID: " + threadList[client]);
                    
                }
                catch (Exception e)
                {
                    Console.WriteLine("Connection lost!" + e);
                    Thread.Sleep(5000);
                    bClientConnected = false;
                    //Environment.Exit(0);
                    // Schakel thread uit wanneer connection is lost.

                }
            }
        }

        // Not needed use Environment.Exit(0); instead
        ///// <summary>
        ///// Stop all the threads of the server object.
        ///// </summary>
        //public void stop()
        //{
        //    _isRunning = false;
        //    foreach (Thread thread in threads)
        //    {
        //        thread.Abort();
        //    }
        //}
    }
}
