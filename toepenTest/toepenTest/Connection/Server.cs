using Newtonsoft.Json;
using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Net;
using System.Net.Sockets;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using toepenTest.Json;

namespace toepenTest.Connection
{
    // The delegate type for hooking up change notifications.
    public delegate void AddedEventHandler(object sender, int e);
    public delegate void FourClientsEventHandler();


    public class Server
    {
        // An event that can be used to be notified whenever
        // there are change notifications
        public event AddedEventHandler Added;
        public event FourClientsEventHandler FourClients;

        //private static IPAddress IP = Conn.GetIP();
        private static IPAddress IP = IPAddress.Parse(Conn.GetLocalIP());
        private TcpListener _server;
        private Dictionary<TcpClient, int> clientList;

        private bool isSearching;
        private bool holdConnection;


        public Server(int port)
        {
            /* To stop all the threads on exit, use Environment.Exit(0); */
            Console.WriteLine("Multi-Threaded TCP Server");
            Console.WriteLine("IPAddress: " + IP.ToString());
            Console.WriteLine("Port: " + port);

            clientList = new Dictionary<TcpClient, int>();
            _server = new TcpListener(IP, port);
            _server.Start();

            isSearching = true;
            holdConnection = true;

            Thread searchThread = new Thread(SearchClients);
            searchThread.Start();
        }


        // Invoke the changed event; called whenever there are change notifications
        protected virtual void OnAdded(int e)
        {
            if (Added != null)
            {
                Added(this, e);
            }
        }

        protected virtual void OnFourClients()
        {
            if (FourClients != null)
            {
                FourClients();
            }
        }


        public async void SearchClients()
        {
            while (isSearching)
            {
                // wait for client connection, then go further
                TcpClient newClient = await _server.AcceptTcpClientAsync();

                // client found
                // create a thread to handle communication
                Thread recieveThread = new Thread(new ThreadStart(delegate { GetResponse(newClient); }));
                recieveThread.Start();
                clientList.Add(newClient, clientList.Count);

                Console.WriteLine(recieveThread.ToString());
                Console.WriteLine("client: " + clientList[newClient]);

                OnAdded(clientList[newClient]);

                if (clientList.Count == 4)
                {
                    isSearching = false;
                    OnFourClients();
                }
            }
        }

        public void GetResponse(TcpClient client)
        {
            //string ipClient = client.Client.LocalEndPoint.ToString();
            //string[] output = ipClient.Split(new[] { ':', ' ' });

            // sets reader stream
            StreamReader sReader = new StreamReader(client.GetStream(), Encoding.ASCII);
            // you could use the NetworkStream to read and write, 
            // but there is no forcing flush, even when requested


            try
            {
                while (holdConnection)
                {
                    // reads from stream
                    string sDataIncomming = sReader.ReadLine();
                    Console.WriteLine("Server recieved from client " + clientList[client] + " : " + sDataIncomming);
                    HandleResponse(sDataIncomming);
                }
            }
            catch (Exception e)
            {
                Console.WriteLine("Connection with client " + clientList[client] + " is lost!; " + e);
                // Terminate thread when connection is lost.
            }
        }

        private void HandleResponse(string sDataIncomming)
        {
            Message message = JsonConvert.DeserializeObject<Message>(sDataIncomming);

            switch (message.Type)
            {
                case "playedCard":
                    //StartGame startGame = JsonConvert.DeserializeObject<StartGame>(message.value);
                    //// shows content on the console.
                    //Console.WriteLine(playCard.Name + " > " + playCard.Card);
                    //if (startGame.start)
                    //{
                    //    OnStartGame(message);
                    //}
                    break;
            }
        }

        /// <summary>
        /// Send a message to a client in a separate thread
        /// </summary>
        /// <param name="messageObj">Must be a serialize Message object</param>
        /// <param name="client">The reciever of the message</param>
        public void SendMessage(Message messageObj, TcpClient client)
        {
            Thread sendThread = new Thread(new ThreadStart(delegate { Send(messageObj, client); }));
            sendThread.Start();
        }

        /// <summary>
        /// Send message to a client
        /// </summary>
        /// <param name="messageObj">Must be a serialize Message object</param>
        /// <param name="client">The reciever of the message</param>
        private void Send(object messageObj, TcpClient client)
        {
            try
            {
                // sets writer stream
                StreamWriter sWriter = new StreamWriter(client.GetStream(), Encoding.ASCII);


                // write data and make sure to flush, or the buffer will continue to 
                // grow, and your data might not be sent when you want it, and will
                // only be sent once the buffer is filled
                sWriter.WriteLine(messageObj);
                sWriter.Flush();
                Console.WriteLine("Server sent to client " + clientList[client] + " : " + messageObj);


                //// to write something back.
                //string response = Console.ReadLine();
                //sWriter.WriteLine(response);
            }
            catch (Exception e)
            {
                Console.WriteLine("Connection with client " + clientList[client] + " is lost!; " + e);
            }
        }


        public void StartGame()
        {

        }
    }
}
