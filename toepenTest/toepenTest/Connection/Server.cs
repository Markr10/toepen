using Newtonsoft.Json;
using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Net;
using System.Net.Sockets;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using toepenTest.Json;

namespace toepenTest.Connection
{
    // The delegate type for hooking up change notifications.
    public delegate void FourClientsEventHandler();


    public class Server
    {
        // An event that can be used to be notified whenever
        // there are change notifications
        public event FourClientsEventHandler FourClientsEvent;

        //private static IPAddress IP = Conn.GetIP();
        private static IPAddress IP = IPAddress.Parse(Conn.GetLocalIP());
        private TcpListener _server;
        private Dictionary<TcpClient, int> clientList;

        private bool isSearching;
        private bool holdConnection;
        private Game gameToepen;


        public Server(int port)
        {
            /* To stop all the threads on exit, use Environment.Exit(0); */
            Console.WriteLine("Multi-Threaded TCP Server");
            Console.WriteLine("IPAddress: " + IP.ToString());
            Console.WriteLine("Port: " + port);

            clientList = new Dictionary<TcpClient, int>();
            _server = new TcpListener(IP, port);
            _server.Start();

            isSearching = true;
            holdConnection = true;
            gameToepen = null;

            Thread searchThread = new Thread(SearchClients);
            searchThread.Start();
        }

        // Invoke the changed event; called whenever there are change notifications
        protected virtual void OnFourClients()
        {
            if (FourClientsEvent != null)
            {
                FourClientsEvent();
            }
        }

        public async void SearchClients()
        {
            while (isSearching)
            {
                // wait for client connection, then go further
                TcpClient newClient = await _server.AcceptTcpClientAsync();

                // client found
                // create a thread to handle communication
                Thread recieveThread = new Thread(new ThreadStart(delegate { GetResponse(newClient); }));
                recieveThread.Start();
                clientList.Add(newClient, clientList.Count);

                Console.WriteLine("client: " + clientList[newClient]);

                PlayerAdded playerAdded = new PlayerAdded();
                playerAdded.Type = "PlayerAdded";
                playerAdded.IndexOfNewPlayer = clientList[newClient];
                SendSpecificMessageAll(JsonConvert.SerializeObject(playerAdded));
                SendEarlier(newClient, playerAdded);

                if (clientList.Count == 4)
                {
                    isSearching = false;
                    OnFourClients();
                }
            }
        }

        public void GetResponse(TcpClient client)
        {
            //string ipClient = client.Client.LocalEndPoint.ToString();
            //string[] output = ipClient.Split(new[] { ':', ' ' });

            // sets reader stream
            StreamReader sReader = new StreamReader(client.GetStream(), Encoding.ASCII);
            // you could use the NetworkStream to read and write, 
            // but there is no forcing flush, even when requested


            try
            {
                while (holdConnection)
                {
                    // reads from stream
                    string sDataIncomming = sReader.ReadLine();
                    Console.WriteLine("Server recieved from client " + clientList[client] + " : " + sDataIncomming);
                    HandleResponse(sDataIncomming);
                }
            }
            catch (Exception e)
            {
                Console.WriteLine("Connection with client " + clientList[client] + " is lost!; " + e);
                // terminate thread when connection is lost
            }
        }

        private void HandleResponse(string sDataIncomming)
        {
            switch (JsonConvert.DeserializeObject<MessageLite>(sDataIncomming).Type)
            {
                case "PlayCard":
                    //StartGame startGame = JsonConvert.DeserializeObject<StartGame>(message.value);
                    //// shows content on the console.
                    //Console.WriteLine(playCard.Name + " > " + playCard.Card);
                    //if (startGame.start)
                    //{
                    //    OnStartGame(message);
                    //}
                    break;
            }
        }

        /// <summary>
        /// Send a message to a client in a separate thread
        /// </summary>
        /// <param name="messageObj">Must be a serialize Message object</param>
        /// <param name="client">The reciever of the message</param>
        public void SendMessage(object messageObj, TcpClient client)
        {
            Thread sendThread = new Thread(new ThreadStart(delegate { Send(messageObj, client); }));
            sendThread.Start();
        }

        /// <summary>
        /// Send message to a client
        /// </summary>
        /// <param name="messageObj">Must be a serialize Message object</param>
        /// <param name="client">The reciever of the message</param>
        private void Send(object messageObj, TcpClient client)
        {
            try
            {
                // sets writer stream
                StreamWriter sWriter = new StreamWriter(client.GetStream(), Encoding.ASCII);


                // write data and make sure to flush, or the buffer will continue to 
                // grow, and your data might not be sent when you want it, and will
                // only be sent once the buffer is filled
                sWriter.WriteLine(messageObj);
                sWriter.Flush();
                Console.WriteLine("Server sent to client " + clientList[client] + " : " + messageObj);


                //// to write something back.
                //string response = Console.ReadLine();
                //sWriter.WriteLine(response);
            }
            catch (Exception e)
            {
                Console.WriteLine("Connection with client " + clientList[client] + " is lost!; " + e);
            }
        }

        /// <summary>
        /// Send a specific message to all the clients in separate threads
        /// </summary>
        /// <param name="messageObj">Must be a serialize Message object</param>
        public void SendSpecificMessageAll(object messageObj)
        {
            foreach (TcpClient client in clientList.Keys)
            {
                SendMessage(messageObj, client);
            }
        }

        /// <summary>
        /// Send a messages to all the clients in separate threads
        /// </summary>
        /// <param name="messageObj">A Message object</param>
        /// <param name="playerIDs">The array with the id of the players</param>
        public void SendMessageAll(Message messageObj, string[] playerIDs)
        {
            TcpClient[] clientArray = clientList.Keys.ToArray();

            // Stop if both lists are not equal.
            if (clientArray.Length != playerIDs.Length)
            {
                return;
            }

            for (int i = 0; i < clientArray.Length; i++)
            {
                messageObj.Id = playerIDs[i];
                SendMessage(JsonConvert.SerializeObject(messageObj), clientArray[i]);
            }
        }


        /// <summary>
        /// Send earlier players to a client
        /// </summary>
        /// <param name="client">The client to which the players must be send</param>
        /// <param name="playerAdded">The PlayerAdded object which was earlier used to send the new player</param>
        public void SendEarlier(TcpClient client, PlayerAdded playerAdded)
        {
            foreach (TcpClient clientFromList in clientList.Keys)
            {
                Console.WriteLine("CFromL " + clientList[clientFromList] + ";CL " + clientList[client]);
                Console.WriteLine("CLKeys " + clientList.Keys.Count);
                if (clientList[clientFromList] == clientList[client])
                {
                    return;
                }

                playerAdded.IndexOfNewPlayer = clientList[clientFromList];
                Console.WriteLine("Send CFromLNumber " + playerAdded.IndexOfNewPlayer + " to " + clientList[client]);
                Console.WriteLine("Info " + JsonConvert.SerializeObject(playerAdded));
                
                SendMessage(JsonConvert.SerializeObject(playerAdded), client);
            }
        }

        public void StartGame()
        {
            // start Game
            gameToepen = new Game(clientList.Count);
            StartGame startGameMess = new StartGame();
            startGameMess.Type = "StartGame";
            startGameMess.Start = true;
            SendMessageAll(startGameMess, gameToepen.getPlayerIDs());
        }
    }
}
